#include "driver.h"

PDEVICE_OBJECT  g_pDeviceObject  = NULL;
PDEVICE_CONTEXT g_pDeviceContext = NULL;
/**
  * @description : Point d'entree du driver
  * @param : DriverObject
  * @param : RegistryPath == chemin dans le registre
  * @return : NTSTATUS
  **/
NTSTATUS DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{

	PDEVICE_OBJECT         deviceObject        = NULL; 
	NTSTATUS               ntStatus; 
	WCHAR                  deviceNameBuffer[]  = L"\\Device\\"DRIVER_NAME; 
	UNICODE_STRING         deviceNameUnicodeString; 
	WCHAR                  deviceLinkBuffer[]  = L"\\DosDevices\\"DRIVER_NAME; 
	UNICODE_STRING         deviceLinkUnicodeString; 
	WCHAR filename[] = L"\\??\\pipe\\framework";
	UNICODE_STRING file_path;
	OBJECT_ATTRIBUTES objatt;
	IO_STATUS_BLOCK iostatus;
		
	
	RtlInitUnicodeString (&deviceNameUnicodeString, deviceNameBuffer);
	RtlInitUnicodeString (&file_path, filename);
	
	//Create and Initialize device object
	ntStatus = IoCreateDevice (DriverObject, 
								sizeof (DEVICE_CONTEXT), 
								&deviceNameUnicodeString, 
								0x6666, 
								0, 
								FALSE, 
								&deviceObject 
								); 
	
	
	if (NT_SUCCESS(ntStatus)) 
	{ 
		RtlInitUnicodeString (&deviceLinkUnicodeString, deviceLinkBuffer);
		ntStatus = IoCreateSymbolicLink (&deviceLinkUnicodeString, &deviceNameUnicodeString);
		
		// Simplification de la communication entre user-mode et kernel-mode
		if (!NT_SUCCESS(ntStatus)) 
		{
			IoDeleteDevice (deviceObject); 
			DbgPrint("DriverEntry: IoCreationSymbolicLink failed");
			return ntStatus; 
		} 
		
		g_pDeviceObject  = deviceObject;
		g_pDeviceContext = deviceObject->DeviceExtension;

		g_pDeviceContext->pDriverObject = DriverObject;
		g_pDeviceContext->pDeviceObject = deviceObject;
		
		
		
		
		
		DriverObject->DriverUnload                         = DriverUnload; 
		DriverObject->MajorFunction[IRP_MJ_CREATE]         = DrvCreateClose;
		DriverObject->MajorFunction[IRP_MJ_CLOSE]          = DrvCreateClose;
		DriverObject->MajorFunction[IRP_MJ_WRITE]          = DrvWrite;
		DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DriverDispatch;
	
		return STATUS_SUCCESS; 
	} 
	else
	{
		DbgPrint("DriverEntry: IOCreateDevice failed");
		return ntStatus; 
	}
}


/**
 * @description : fonction permettant de decharger correctement le driver
 * @param : DriverObject
 * @return : void
 **/
VOID DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    WCHAR                  deviceLinkBuffer[]  = L"\\DosDevices\\"DRIVER_NAME;
    UNICODE_STRING         deviceLinkUnicodeString;
   	DbgPrint("Unload driver...\n");
	RtlInitUnicodeString (&deviceLinkUnicodeString,deviceLinkBuffer);
	IoDeleteSymbolicLink (&deviceLinkUnicodeString);
	IoDeleteDevice (DriverObject->DeviceObject);
}	


/**
 * @description : Fonction qui va recuperer les IRP : DeviceIO
 * @param : DeviceObject
 * @param : IRP
 * @return : NTSTATUS
 **/
NTSTATUS DriverDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
	PIO_STACK_LOCATION      irpStack;
    PVOID                   inputBuffer;
    PVOID                   outputBuffer;
    ULONG         	         inputBufferLength;
    ULONG                   outputBufferLength;
    ULONG                   ioControlCode;
    NTSTATUS 				ntStatus;
	IO_STATUS_BLOCK 		iostatus;
	
	WCHAR filename[] = L"\\??\\pipe\\framework";
	WCHAR filenamenet[] = L"\\??\\pipe\\frameworkNet";
	UNICODE_STRING file_path;
	UNICODE_STRING file_path_net;
	OBJECT_ATTRIBUTES objatt;
	// IO_STATUS_BLOCK iostatus;
	
	RtlInitUnicodeString (&file_path, filename);
	RtlInitUnicodeString (&file_path_net, filenamenet);
   
    Irp->IoStatus.Status      = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    inputBuffer             = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength       = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBuffer            = Irp->AssociatedIrp.SystemBuffer;
    outputBufferLength      = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    ioControlCode           = irpStack->Parameters.DeviceIoControl.IoControlCode;

	Irp->IoStatus.Status = STATUS_SUCCESS;
    switch (irpStack->MajorFunction) 
	{
		case IRP_MJ_DEVICE_CONTROL: 
			
			if( IOCTL_DKF_START == ioControlCode)
			{
				InitializeObjectAttributes(&objatt, &file_path, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL); 
				ntStatus = ZwCreateFile(&handlelog, GENERIC_ALL, &objatt, &iostatus, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL,0);		
				
				InitializeObjectAttributes(&objatt, &file_path_net, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL); 
				ntStatus = ZwCreateFile(&handlenet, GENERIC_ALL, &objatt, &iostatus, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL,0);	
				trace =0;
				trace_net=0;
				ntStatus= CmRegisterCallback(RegistryCallback, g_pDeviceContext, &g_pDeviceContext->RegCookie);
				ntStatus = Hook_Function();
				UserLandID = PsGetCurrentProcessId();
			}
			
			if( IOCTL_DKF_STOP == ioControlCode)
			{
				Unhook_fonction();
				ntStatus = CmUnRegisterCallback(g_pDeviceContext->RegCookie);
				ZwClose(handlelog);
			}
			break;
		default:
			DbgPrint("Device IO Control Erropr code\n");
			break;
	}
	
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return Irp->IoStatus.Status;
}

/**
 * @description : Fonction qui va recuperer les IRP CREATE ET CLOSE
 * @param : DeviceObject
 * @param : IRP
 * @return : NTSTATUS
 **/

NTSTATUS DrvCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
	Irp->IoStatus.Status      = STATUS_SUCCESS;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return Irp->IoStatus.Status;
}


NTSTATUS DrvWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
	Irp->IoStatus.Status      = STATUS_SUCCESS;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return Irp->IoStatus.Status;
}


/**
 * @description : Fonction plaçant les hooks sur la SSDT
 * @param : aucun
 * @return : NTSTATUS
 **/
 NTSTATUS Hook_Function()
 {
	g_pmdlSystemCall=IoAllocateMdl(KeServiceDescriptorTable.ServiceTableBase, KeServiceDescriptorTable.NumberOfServices*4, 0, 0, NULL);

   	if(!g_pmdlSystemCall)
      	return STATUS_UNSUCCESSFUL;

   	MmBuildMdlForNonPagedPool(g_pmdlSystemCall);
	
	MappedSystemCallTable=MmMapLockedPages(g_pmdlSystemCall, KernelMode);

	__try{
		OldNtDeviceIoControlFile =  (PVOID) InterlockedExchange( (PLONG) &MappedSystemCallTable[107], (LONG) NewNtDeviceIoControlFile);
		OldNtOpenFile =  (PVOID) InterlockedExchange( (PLONG) &MappedSystemCallTable[179], (LONG) NewNtOpenFile);
		OldNtOpenProcess =  (PVOID) InterlockedExchange( (PLONG) &MappedSystemCallTable[190], (LONG) NewNtOpenProcess);
		OldNtReadFile =  (PVOID) InterlockedExchange( (PLONG) &MappedSystemCallTable[273], (LONG) NewNtReadFile);
		OldNtWriteFile =  (PVOID) InterlockedExchange( (PLONG) &MappedSystemCallTable[396], (LONG) NewNtWriteFile);
		OldNtCreateFile = (PVOID) InterlockedExchange( (PLONG) &MappedSystemCallTable[66], (LONG) NewNtCreateFile);
		OldNtTerminateProcess = (PVOID) InterlockedExchange( (PLONG) &MappedSystemCallTable[370], (LONG) NewNtTerminateProcess);
		OldNtCreateSection = (PVOID) InterlockedExchange( (PLONG) &MappedSystemCallTable[84], (LONG) NewNtCreateSection);
		IsHooked = 1;
	}
	__except(1){
			DbgPrint("DriverEntry: Hook failed");

	}
	return STATUS_SUCCESS;
 }
 
 /**
  * @description : permet de de-hooker la SSDT
  * @param :  aucun
  * @return : void
  **/
 void Unhook_fonction()
{	

	__try
	{
		 InterlockedExchange( (PLONG) &MappedSystemCallTable[66], (LONG) OldNtCreateFile);
		 InterlockedExchange( (PLONG) &MappedSystemCallTable[273], (LONG) OldNtReadFile);
		 InterlockedExchange( (PLONG) &MappedSystemCallTable[396], (LONG) OldNtWriteFile);
		 InterlockedExchange( (PLONG) &MappedSystemCallTable[107], (LONG) OldNtDeviceIoControlFile);
		 InterlockedExchange( (PLONG) &MappedSystemCallTable[179], (LONG) OldNtOpenFile);
		 InterlockedExchange( (PLONG) &MappedSystemCallTable[190], (LONG) OldNtOpenProcess);
		 InterlockedExchange( (PLONG) &MappedSystemCallTable[370], (LONG) OldNtTerminateProcess);
		 InterlockedExchange( (PLONG) &MappedSystemCallTable[84], (LONG) OldNtCreateSection);
		 IsHooked = 0;
	}
	__except(1){
			DbgPrint("DriverEntry: Unhook failed");
	}
 
    // Unlock and Free MDL
	if(g_pmdlSystemCall)
	{
	DbgPrint("Unhook Function \n");
		MmUnmapLockedPages(MappedSystemCallTable, g_pmdlSystemCall);
		IoFreeMdl(g_pmdlSystemCall);
	}
	DbgPrint("Unhook Function \n");
}
 