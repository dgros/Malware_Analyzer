#include "driver.h"

void GetSecurityContextSubjectReg(char * name, char * security_type)
{
	int i, taille;
	char temp[200];
	char temp2[200];
	PAGED_CODE();
	RtlZeroMemory(&temp, sizeof(temp));
	RtlZeroMemory(&temp2, sizeof(temp2));
	
	sprintf(temp,"system_u:system_r:");
	taille = strlen(name);
	i=0;
	while( i < taille && i < 13 ) 
	{
		if(name[i] != '.')
			temp2[i] = name[i];
		else
			break;
		i++;
	}
	sprintf(security_type, "%s%s_t", temp,temp2);
}

NTSTATUS RegistryCallback(IN PVOID CallbackContext, 
						  IN PVOID  Argument1, 
						  IN PVOID  Argument2)
{
	NTSTATUS            			  	ntStatus; 
	PDEVICE_CONTEXT 					pContext = (PDEVICE_CONTEXT) CallbackContext;
	REG_NOTIFY_CLASS 					Action   = (REG_NOTIFY_CLASS) Argument1;
	POBJECT_NAME_INFORMATION 			ObjectNameInfo;
	ULONG 								ReturnLength,ReturnLength1;
	UNICODE_STRING      				*path_str = NULL;
	UNICODE_STRING    				    *key = NULL;
	UNICODE_STRING   				    *value = NULL;
	UNICODE_STRING        				*data = NULL;
	UNICODE_STRING				        unicode_registry ;
	UNICODE_STRING        				KeyInformation;
	UNICODE_STRING 				       *unicode_test=NULL;
	ANSI_STRING 						key_ansi;
	ANSI_STRING 						value_ansi;
	ANSI_STRING 						temp_ansi;
	ANSI_STRING 						pathname_ansi;
	size_t 								size = 9;
	ProcessInformationFile 				process;
	ProcessInformation 					process_uni;
	char 								security_sbject[525];
	char 								droit[324];
	char								droit_temp[300];
	char 								buf_temp[1024];
	int 								bool =0;
	
	PAGED_CODE();
	if( ExGetPreviousMode() == KernelMode)
		return STATUS_SUCCESS;
		
	RtlZeroMemory(&security_sbject, sizeof(security_sbject));
	RtlZeroMemory(&droit, sizeof(droit));
	RtlZeroMemory(&droit_temp, sizeof(droit_temp));
	RtlZeroMemory(&buf_temp, sizeof(buf_temp));
	

	switch (Action) 
	{

		case RegNtPreDeleteKey:
			{

				PREG_DELETE_KEY_INFORMATION pInfo = (PREG_DELETE_KEY_INFORMATION) Argument2;
				__try{
						ntStatus = ObQueryNameString(pInfo->Object, (POBJECT_NAME_INFORMATION)key, 0, &ReturnLength);
						key = (PUNICODE_STRING)ExAllocatePoolWithTag(NonPagedPool, ReturnLength, 0);
						if (ntStatus == STATUS_INFO_LENGTH_MISMATCH)
						{	
							if (key)
							{
								ntStatus = ObQueryNameString(pInfo->Object, (POBJECT_NAME_INFORMATION)key, ReturnLength, &ReturnLength);
							}
							else
								return STATUS_SUCCESS;
						}
						
						process = GetProcessInfoFile();
						if(process.pid == 4)
						{
							sprintf(security_sbject,"system_u:system_r:system_t");
							RtlZeroMemory(&process.pathname, sizeof(process.pathname));
							sprintf(process.pathname, "System");
						}
						else
							GetSecurityContextSubject(process, security_sbject);
							
						GetSecurityContextSubject(process, security_sbject);
						RtlUnicodeStringToAnsiString(&key_ansi, key, TRUE);
						sprintf(droit,"delete ");
						bool = 1;
						
				}
				__except(EXCEPTION_EXECUTE_HANDLER)
				{
					ntStatus=GetExceptionCode();
					DbgPrint("Exception RegNtPreDeleteKey : %x\n", ntStatus);
				}
				
				ExFreePoolWithTag(key,0);
				break;
			}

		case RegNtPreCreateKeyEx:
			{
				PREG_CREATE_KEY_INFORMATION pInfo = (PREG_CREATE_KEY_INFORMATION) Argument2;
				__try{

					ntStatus = ObQueryNameString(pInfo->RootObject, (POBJECT_NAME_INFORMATION)path_str, 0, &ReturnLength);
					path_str = (PUNICODE_STRING)ExAllocatePoolWithTag(NonPagedPool, ReturnLength, 0);
					if (ntStatus == STATUS_INFO_LENGTH_MISMATCH)
					{
						if (path_str)
						{
							ntStatus = ObQueryNameString(pInfo->RootObject, (POBJECT_NAME_INFORMATION)path_str, ReturnLength, &ReturnLength);
						}
						else
								return STATUS_SUCCESS;
					}
					
					process_uni = GetProcessInfo();	
					if(process_uni.pid == 4)
								return STATUS_SUCCESS;
							else
								GetSecurityContextSubjectReg(process_uni.name,security_sbject);
							
					GetDroit(droit, pInfo);
					//sprintf(droit, "create_key_function %s", droit_temp);
					RtlUnicodeStringToAnsiString(&key_ansi, pInfo->CompleteName, TRUE);
					
					WriteInLog(droit,process_uni.pid, process_uni.name, process_uni.ppid , key_ansi.Buffer ,security_sbject , "system_u:object_r:registry_t", "registry",0,0);
				}
				__except(EXCEPTION_EXECUTE_HANDLER)
				{
					ntStatus=GetExceptionCode();
					DbgPrint("Exception RegNtPreCreateKeyEx : %x\n", ntStatus);
				}
				// ExFreePoolWithTag(path_str,0);
				break;
			}

		case RegNtSetValueKey:
			{
				PREG_SET_VALUE_KEY_INFORMATION pInfo = (PREG_SET_VALUE_KEY_INFORMATION) Argument2;
				
				__try{
					ntStatus = ObQueryNameString(pInfo->Object, (POBJECT_NAME_INFORMATION)key, 0, &ReturnLength);
					key = (PUNICODE_STRING)ExAllocatePoolWithTag(NonPagedPool, ReturnLength, 1);
					if (ntStatus == STATUS_INFO_LENGTH_MISMATCH)
					{
						if (key)
						{
							ntStatus = ObQueryNameString(pInfo->Object, (POBJECT_NAME_INFORMATION)key, ReturnLength, &ReturnLength);
							process_uni = GetProcessInfo();	
							
							if(process_uni.pid == 4)
								return STATUS_SUCCESS;
							else
								GetSecurityContextSubjectReg(process_uni.name,security_sbject);
							
							RtlUnicodeStringToAnsiString(&key_ansi, key, TRUE);
							sprintf(droit, "setvaluekey "); 
							DbgPrint("%wZ \n", pInfo->ValueName);
							WriteInLog(droit,process_uni.pid, process_uni.name, process_uni.ppid , key_ansi.Buffer ,security_sbject , "system_u:object_r:registry_t", "registry",0,0);
						}
					}
					if(key)
						ExFreePoolWithTag(key,1);
					
				}
				__except(EXCEPTION_EXECUTE_HANDLER)
				{
					ntStatus=GetExceptionCode();
					DbgPrint("Exception RegNtSetValueKey : %x\n", ntStatus);
				}
				break;
			}
		case RegNtQueryValueKey:
			{
				PREG_QUERY_VALUE_KEY_INFORMATION pInfo = (PREG_QUERY_VALUE_KEY_INFORMATION) Argument2;
				
				__try
				{
					ntStatus = ObQueryNameString(pInfo->Object, (POBJECT_NAME_INFORMATION)key, 0, &ReturnLength);
					key = (PUNICODE_STRING)ExAllocatePoolWithTag(NonPagedPool, ReturnLength, 1);
					if (ntStatus == STATUS_INFO_LENGTH_MISMATCH)
					{
						if (key)
						{
							ntStatus = ObQueryNameString(pInfo->Object, (POBJECT_NAME_INFORMATION)key, ReturnLength, &ReturnLength);
							
							process_uni = GetProcessInfo();	
							
							if(process_uni.pid == 4)
								return STATUS_SUCCESS;
							else
								GetSecurityContextSubjectReg(process_uni.name,security_sbject);
						
							switch(pInfo->KeyValueInformationClass)
							{
								case 0: {sprintf(droit, "KeyValueBasicInformation "); break;}
								case 1: {sprintf(droit, "KeyValueFullInformation "); break;}
								case 2: {sprintf(droit, "KeyValuePartialInformation "); break;}
								case 3: {sprintf(droit, "KeyValueFullInformationAlign64 "); break;}
								case 4: {sprintf(droit, "KeyValuePartialInformationAlign64 "); break;}
								case 5: {sprintf(droit, "MaxKeyValueInfoClass "); break;}
								default: break;
							}
							
							RtlUnicodeStringToAnsiString(&key_ansi, key, TRUE);

							// bool = 1;
						WriteInLog(droit,process_uni.pid, process_uni.name, process_uni.ppid , key_ansi.Buffer ,security_sbject , "system_u:object_r:registry_t", "registry",0,0);
							if(key)
								ExFreePoolWithTag(key,1);
						}
					}
				
				}
				__except(EXCEPTION_EXECUTE_HANDLER)
				{
					ntStatus=GetExceptionCode();
					DbgPrint("Exception : %x\n", ntStatus);
				}
	
				break;
			}
			
		case RegNtQueryKey:
			{
				PREG_QUERY_KEY_INFORMATION pInfo = (PREG_QUERY_KEY_INFORMATION) Argument2;
				
				__try{
					ntStatus = ObQueryNameString(pInfo->Object, (POBJECT_NAME_INFORMATION)key, 0, &ReturnLength);
					key = (PUNICODE_STRING)ExAllocatePoolWithTag(NonPagedPool, ReturnLength, 1);
					if (ntStatus == STATUS_INFO_LENGTH_MISMATCH)
					{
						if (key)
						{
							ntStatus = ObQueryNameString(pInfo->Object, (POBJECT_NAME_INFORMATION)key, ReturnLength, &ReturnLength);
					
							process_uni = GetProcessInfo();	
							
							if(process_uni.pid == 4)
								return STATUS_SUCCESS;
							else
								GetSecurityContextSubjectReg(process_uni.name,security_sbject);
													
							switch(pInfo->KeyInformationClass)
							{
								case 0: {sprintf(droit, "KeyBasicInformation "); break;}
								case 1: {sprintf(droit, "KeyNodeInformation "); break;}
								case 2: {sprintf(droit, "KeyFullInformation "); break;}
								case 3: {sprintf(droit, "KeyNameInformation "); break;}
								case 4: {sprintf(droit, "KeyCachedInformation "); break;}
								case 5: {sprintf(droit, "KeyFlagsInformation "); break;}
								case 6: {sprintf(droit, "KeyVirtualizationInformation "); break;}
								case 7: {sprintf(droit, "KeyHandleTagsInformation "); break;}
								case 8: {sprintf(droit, "MaxKeyInfoClass "); break;}
								default: break;
							}
							RtlUnicodeStringToAnsiString(&key_ansi, key, TRUE);
							// RtlUnicodeStringToAnsiString(&pathname_ansi, process_uni.pathname, TRUE);
							
							WriteInLog(droit,process_uni.pid, process_uni.name, process_uni.ppid , key_ansi.Buffer ,security_sbject , "system_u:object_r:registry_t", "registry",0,0);
							// bool = 1;
						
							// if(key)
								// ExFreePoolWithTag(key,1);
						}
					}
				}
				__except(EXCEPTION_EXECUTE_HANDLER)
				{
					ntStatus=GetExceptionCode();
					DbgPrint("Exception : %x\n", ntStatus);
				}
				
				break;
			}

		case RegNtPreOpenKeyEx:
			{
				PREG_CREATE_KEY_INFORMATION pInfo = (PREG_CREATE_KEY_INFORMATION) Argument2;
				
				__try{
					process_uni = GetProcessInfo();	
					if(process_uni.pid == 4)
							return STATUS_SUCCESS;
							
					RtlUnicodeStringToAnsiString(&pathname_ansi, process_uni.pathname, TRUE);
				
					GetSecurityContextSubjectReg(process_uni.name,security_sbject);
					GetDroit(droit, pInfo);
					//sprintf(droit, "open_key_function %s", droit_temp);
					RtlUnicodeStringToAnsiString(&key_ansi, pInfo->CompleteName, TRUE);
					// bool = 1;
					WriteInLog(droit,process_uni.pid, process_uni.name, process_uni.ppid , key_ansi.Buffer ,security_sbject , "system_u:object_r:registry_t", "registry",0,0);
					
				}
				__except(EXCEPTION_EXECUTE_HANDLER)
				{
					ntStatus=GetExceptionCode();
					DbgPrint("Exception : %x\n", ntStatus);
				}
				break;
			}	
			
		default:
			{
				break;
			}
	}
	
	if(bool == 1)
	{
		WriteInLog(droit, process.pid, process.pathname, process.ppid , key_ansi.Buffer ,security_sbject , "system_u:object_r:registry_t", "registry", 0,0);
		
	}


	return STATUS_SUCCESS;
}



ProcessInformation GetProcessInfo()
{
	PEPROCESS pep;
	ULONG ret,retlen;
	NTSTATUS rc,status;
	ProcessInformation  process;
	PFILE_OBJECT fileObject = NULL;
	
	PUNICODE_STRING temp_unicode;
	PVOID unicode;
	ULONG ppid = 0;
	PCHAR toto;
	
	PAGED_CODE();
	
	// On recupere le PID
	process.pid = (LONG)PsGetCurrentProcessId();
		
	PsLookupProcessByProcessId ((HANDLE)process.pid,&pep);
	toto = (PCHAR) pep;
	process.ppid = *((ULONG*)(toto+0x140));
	// On recupere les 16 premiers bits du nom du process
	process.name = PsGetProcessImageFileName(pep);

	// On recupere le path complet du process
	rc = ZwQueryInformationProcess(ZwCurrentProcess(), ProcessImageFileName, NULL, 0, &ret);
								

	if(rc == STATUS_INFO_LENGTH_MISMATCH)
	{
		retlen = ret - sizeof(UNICODE_STRING);
		unicode = ExAllocatePool(NonPagedPool, ret);
		process.pathname = (PUNICODE_STRING) ExAllocatePool(NonPagedPool, sizeof(UNICODE_STRING));
		
		// if(process.pathname->MaximumLength <  retlen)
		// {
			// RtlInitUnicodeString(process.pathname, L"Echec" );
			// return process;
		// }	
		
		
		if(unicode != NULL)
		{	
			RtlInitUnicodeString(process.pathname,0);
			rc = ZwQueryInformationProcess(ZwCurrentProcess(), ProcessImageFileName, unicode, ret, &ret);
			if( rc == STATUS_SUCCESS)
			{
				 temp_unicode = (PUNICODE_STRING) unicode;
				 // process.pathname = (PUNICODE_STRING) ExAllocatePool(NonPagedPool, temp_unicode->Length);
				 RtlCopyUnicodeString(process.pathname, temp_unicode );
				// RtlInitUnicodeString(process.pathname, unicode );
			}
			else
				RtlInitUnicodeString(process.pathname, L"Echec" );
			
			ExFreePool(unicode);
		}
	}
	
	return process;
}

void GetDroit(char * droit, PREG_CREATE_KEY_INFORMATION pInfo)
{
	if ( (pInfo->DesiredAccess & KEY_QUERY_VALUE) )
	{
		sprintf(droit,"%skey_query_value ", droit);
	}
	if ( (pInfo->DesiredAccess & KEY_SET_VALUE) )
	{
		sprintf(droit,"%skey_set_value ", droit);
	}
	if ( (pInfo->DesiredAccess & KEY_CREATE_SUB_KEY) )
	{
		sprintf(droit,"%skey_create_sub_key ", droit);
	}
	if ( (pInfo->DesiredAccess & KEY_ENUMERATE_SUB_KEYS) )
	{
		sprintf(droit,"%skey_enumerate_sub_key ", droit);
	}
	if ( (pInfo->DesiredAccess & KEY_CREATE_LINK) )
	{
		sprintf(droit,"%skey_create_link ", droit);
	}
	if ( (pInfo->DesiredAccess & KEY_READ) )
	{
		sprintf(droit,"%skey_read ", droit);
	}
	if ( (pInfo->DesiredAccess & KEY_WRITE) )
	{
		sprintf(droit,"%skey_write ", droit);
	}
	if ( (pInfo->DesiredAccess & KEY_EXECUTE) )
	{
		sprintf(droit,"%skey_execute ", droit);
	}
	if ( (pInfo->DesiredAccess & KEY_ALL_ACCESS) )
	{
		sprintf(droit,"%skey_all_access ", droit);
	}
		
	if ( (pInfo->DesiredAccess & DELETE) )
	{
		sprintf(droit,"%sdelete ", droit);
	}
	if ( (pInfo->DesiredAccess & READ_CONTROL) )
	{
		sprintf(droit,"%sread_control ", droit);
	}
	if ( (pInfo->DesiredAccess & WRITE_DAC) )
	{
		sprintf(droit,"%swrite_dac ", droit);
	}
	if ( (pInfo->DesiredAccess & WRITE_OWNER) )
	{
		sprintf(droit,"%swrite_owner ", droit);
	}
	if ( (pInfo->DesiredAccess & GENERIC_READ) )
	{
		sprintf(droit,"%sgen_read ", droit);
	}
	if ( (pInfo->DesiredAccess & GENERIC_WRITE) )
	{
		sprintf(droit,"%sgen_write ", droit);
	}
	if ( (pInfo->DesiredAccess & GENERIC_EXECUTE) )
	{
		sprintf(droit,"%gen_execute ", droit);
	}
	if ( (pInfo->DesiredAccess & GENERIC_ALL) )
	{
		sprintf(droit,"%sgen_all ", droit);
	}
	if ( (pInfo->DesiredAccess & MAXIMUM_ALLOWED) )
	{
		sprintf(droit,"%smax_allowed ", droit);
	}

}