#include "driver.h"

int tour=0;

void checkSSDT()
{
		if(NewNtOpenFile != MappedSystemCallTable[179])
			FonctionDeLaMortQuiTueQuiFaitDesBSODEtQueMemeLesLinuxiensNePeuventPasFaireParceQuIlsSontJaloux();
		if(NewNtOpenProcess !=  MappedSystemCallTable[190] )
			FonctionDeLaMortQuiTueQuiFaitDesBSODEtQueMemeLesLinuxiensNePeuventPasFaireParceQuIlsSontJaloux();
		if(NewNtReadFile != MappedSystemCallTable[273] )
			FonctionDeLaMortQuiTueQuiFaitDesBSODEtQueMemeLesLinuxiensNePeuventPasFaireParceQuIlsSontJaloux();
		if(NewNtCreateFile != MappedSystemCallTable[66])
			FonctionDeLaMortQuiTueQuiFaitDesBSODEtQueMemeLesLinuxiensNePeuventPasFaireParceQuIlsSontJaloux();
		if(NewNtTerminateProcess != MappedSystemCallTable[370] )
			FonctionDeLaMortQuiTueQuiFaitDesBSODEtQueMemeLesLinuxiensNePeuventPasFaireParceQuIlsSontJaloux();
		if(NewNtCreateSection != MappedSystemCallTable[84])
			FonctionDeLaMortQuiTueQuiFaitDesBSODEtQueMemeLesLinuxiensNePeuventPasFaireParceQuIlsSontJaloux();
	

}

void WriteInLog(char *droit, int pid, char * path,int  ppid,char * obj_path,char * scontext, char * tcontext, char * class, NTSTATUS status, LONG size)
{
	IO_STATUS_BLOCK iostatus;
	NTSTATUS retour;
	char bufferpipe[1000];
	LARGE_INTEGER time;
	PAGED_CODE();
	KeQuerySystemTime(&time);
	
	RtlZeroMemory(&bufferpipe, sizeof(bufferpipe));
	
	trace++;
	__try
	{
		if(pid == 4)
			sprintf(bufferpipe,"audit(%I64d,%i) avc=audit { %s} for pid=%i comm=\"System\" ppid=%i path=\"%s\" scontext=%s tcontext=%s tclass=%s return=%x size=%i endoftrace \n", time.QuadPart, trace, droit, pid, ppid, obj_path, scontext, tcontext, class, status, size);
		else	
			sprintf(bufferpipe,"audit(%I64d,%i) avc=audit { %s} for pid=%i comm=\"%s\" ppid=%i path=\"%s\" scontext=%s tcontext=%s tclass=%s return=%x size=%i endoftrace \n", time.QuadPart, trace, droit, pid, path, ppid, obj_path, scontext, tcontext, class, status, size);
		// tour++;
	}
	__except(1)
	{
		DbgPrint("Oupsss\n");
	}
	
	{
		// DbgPrint("%s\n", buffer);
		retour = 0;
		
		retour = ZwWriteFile(handlelog, NULL, NULL, NULL, &iostatus, bufferpipe, strlen(bufferpipe), 0, NULL);		
		// DbgPrint("%s\n",buffer);
		tour++;
		
		if(tour == 100)
		{
			//checkSSDT();
			tour = 0;
		}
		ZwFlushBuffersFile(handlelog, &iostatus);
		RtlZeroMemory(&bufferpipe, sizeof(bufferpipe));
	
	}
	
	
	if(!NT_SUCCESS(retour))
	{
		DbgPrint("Error Ecriture %x\n", retour);
	}
}

ProcessInformationFile GetProcessInfoFile()
{
	PEPROCESS pep;
	ULONG ret;
	NTSTATUS rc,status;
	ProcessInformationFile  process;
	PFILE_OBJECT fileObject = NULL;
	ANSI_STRING temp;
	UNICODE_STRING temp_unicode;
	PVOID unicode;
	ULONG ppid = 0;
	PCHAR toto;
	
	PAGED_CODE();
	// On recupere le PID
	process.pid = (LONG)PsGetCurrentProcessId();
	
	PsLookupProcessByProcessId((HANDLE)process.pid,&pep);
	toto = (PCHAR) pep;
	process.ppid = *((ULONG*)(toto+0x140));
	// On recupere les 16 premiers bits du nom du process
	process.name = PsGetProcessImageFileName(pep);

	// On recupere le path complet du process
	rc = ZwQueryInformationProcess(ZwCurrentProcess(),
								ProcessImageFileName,
								NULL,
								0,
								&ret);
								
								
	if(rc == STATUS_INFO_LENGTH_MISMATCH)
	{
		unicode = ExAllocatePool(PagedPool, ret);
		if(unicode != NULL)
		{
			rc = ZwQueryInformationProcess(ZwCurrentProcess(), ProcessImageFileName, unicode, ret, &ret);
			
			if(NT_SUCCESS(rc))
			{
				// DbgPrint("IRQL : %x \n", KeGetCurrentIrql()),
				RtlInitUnicodeString(&temp_unicode, unicode );
				RtlUnicodeStringToAnsiString(&temp, &temp_unicode, TRUE);
				sprintf(process.pathname,"%s", &temp.Buffer[4]);
				RtlFreeAnsiString(&temp);
			}
			// RtlFreeUnicodeString(&temp_unicode);
			ExFreePool(unicode);
			
		}
	}
	
	return process;
}


int GetObjectType(PUNICODE_STRING object)
{	
	ANSI_STRING toto;
	int i;
	char test[555];
	char ext[4];
	int nb_ext3 = 34;
	char * ext3[34]={".exe", \
	".jpg", \
	".dll", \
	".wer", \
	".ini", \
	".sys", \
	".HOM", \
	".log", \
	".edb", \
	".txt", \
	".mp3", \
	".wav", \
	".avi" , \
	".tmp" , \
	".bat" , \
	".dat", \
	".sdb" , \
	".Bin" , \
	".wmv" , \
	".etl" , \
	".xml" , \
	".sqm" , \
	".mui" , \
	".zip" , \
	".chk" ,\
	".DRV" ,\
	".cpl" ,\
	".url" ,\
	".msi" ,\
	".lnk", \
	".chm" ,\
	".cnt" ,\
	".nld" ,\
	".hlp"
	};
	// char * ext4[]={};
	char * ext7[1]={".Config"};
	int type = 0, longueur,aze=0, temp=0;
	char directory1[]="\\";
	char directory2[]=":";
	char device1[]="}";
	
	PAGED_CODE();
	
	RtlUnicodeStringToAnsiString(&toto, object, TRUE);
	sprintf(test,"%s",toto.Buffer);
	sprintf(ext,"%s",&test[strlen(test)-1 ]);
	
	
	//if( !strcmp(ext, device1) )
		//	return 4;
	RtlUnicodeStringToAnsiString(&toto, object, TRUE);
	sprintf(test,"%s",toto.Buffer);
	longueur = strlen(test);
	RtlFreeAnsiString(&toto);
	
	if( (test[1] == 'D'&& test[2]=='E' && test[3]=='V' && test[8]!= 'H') || (test[1] == 'D'&& test[2]=='e' && test[3]=='v' && test[8]!= 'H') || (test[4] == 'V'&& test[5]=='o' && test[6]=='l') || (test[4] == 'V'&& test[5]=='O' && test[6]=='L')) return 4; //Device
	if( (test[4] == 'P'&& test[5]=='I' && test[6]=='P' && test[7] =='E' )) return 4; // Device
	if( (test[4] == 'S'&& test[5]=='T' && test[6]=='O' && test[7] =='R' )) return 4; // Device
	if( (test[4] == 'F'&& test[5]=='D' && test[6]=='C' )) return 4; // Device
	if( (test[4] == 'I'&& test[5]=='D' && test[6]=='E') ) return 4; // Device
	if( (test[4] == 'i'&& test[5]=='d' && test[6]=='e') ) return 4; // Device
	if( (test[4] == 'f'&& test[5]=='d' && test[6]=='c') ) return 4; // Device
	if( (test[4] == 's'&& test[5]=='t' && test[6]=='o') ) return 4; // Device
	if( (test[4] == 'i'&& test[5]=='d' && test[6]=='e') ) return 4; // Device
	if( (test[1] == 'M'&& test[2]=='o' && test[3]=='u' && test[4]=='n' && test[5]=='t' ) ) return 4; //Device
	if( (test[1] == 'S'&& test[2]=='e' && test[3]=='s' && test[4]=='s' && test[5]=='i' ) ) return 4; //Device
	
	if(!strcmp(ext,directory1) )
		return 3; //Directory
	if( !strcmp(ext, directory2) )
			return 3; //Directory
	
	while(longueur > 0)
	{
		if(test[longueur] == '.') break;
		aze++;
		longueur--;
	}
	if(longueur == 0)
		return 3;
	temp = aze;
	
	// type
	// 1 : file
	// 2 : driver
	// 3 : directory
	// 4 : device	
	switch (aze)
	{
		case 2:
			return 1;
			break;
		case 3:
			return 1;
			break;
		case 4:
			sprintf(ext,"%s",&test[strlen(test)-4]);
			for(i=0; i<nb_ext3;i++)
			{
				if(!_stricmp(ext, ext3[i]))
				{
					if(!_stricmp(ext,ext3[5]))
						type = 2;
					else
					{
						if(!_stricmp(ext,ext3[6]))
							type = 3;
						else
							type = 1;
					}
				break;
				}		
			}
			break;
		case 5:
			return 1;
			break;
		case 6:
			return 1;
			break;
		case 7:
			sprintf(ext,"%s",&test[strlen(test)-7]);
			for(i=0; i<1;i++)
			{
				if(!strcmp(ext, ext7[i]))
				{
					type = 1;
				break;
				}		
			}
			return 1;
			break;
		case 9:
			return 1;
			break;
		case 14:
			return 1;
			break;
		default:
			return 3;
	}
	return type;
}


void GetSecurityContextSubject(ProcessInformationFile process, char * security_type)
{
	int i, taille;
	char temp[200];
	char temp2[200];
	PAGED_CODE();
	RtlZeroMemory(&temp, sizeof(temp));
	RtlZeroMemory(&temp2, sizeof(temp2));
	
	sprintf(temp,"system_u:system_r:");
	taille = strlen(process.name);
	i=0;
	while( i < taille && i < 13 ) 
	{
		if(process.name[i] != '.')
			temp2[i] = process.name[i];
		else
			break;
		i++;
	}
	sprintf(security_type, "%s%s_t", temp,temp2);
}

void TransformToContextFile(ANSI_STRING ansi, char * context)
{
	int taille, i=0, j=0;
		
	taille = strlen(ansi.Buffer);
	i=taille;
	
	while(i>0)
	{
		if(ansi.Buffer[i] == '\\')
			break;
		i--;
	}
	i++;
	j=0;
	while(i<taille)
	{
		if(ansi.Buffer[i] == '.')
			break;
		context[j] = ansi.Buffer[i];
		j++;i++;
	}
}

NTSTATUS  NewNtOpenFile(
  __out  PHANDLE FileHandle,
  __in   ACCESS_MASK DesiredAccess,
  __in   POBJECT_ATTRIBUTES ObjectAttributes,
  __out  PIO_STATUS_BLOCK IoStatusBlock,
  __in   ULONG ShareAccess,
  __in   ULONG OpenOptions
)
{
	NTSTATUS retour, status,ntStatus;
	ULONG ret, retLen;
	int i, j, rc, taille;
	int bool=0;
	char droit[100];
	char sectype[14];
	int  type;
	
	char temp[1024];
	char object_context[1024];
	char securitycontext[525];
	ProcessInformationFile process;
	ANSI_STRING temp_type;
	ANSI_STRING ansi_cible;
	UNICODE_STRING        *path_str = NULL;
	//PAGED_CODE();
	
	__try{
		retour = ( (NTOPENFILE)(*OldNtOpenFile) ) (
				FileHandle,
				DesiredAccess,
				ObjectAttributes,
				IoStatusBlock,
				ShareAccess,
				OpenOptions);
	}
	__except(1)
	{
		DbgPrint("Oupss\n");
	}
	process = GetProcessInfoFile();
	
	if(process.pid == (int)UserLandID)
		return retour;
					
	if(ExGetPreviousMode() == UserMode)
	{
		
		RtlZeroMemory(&droit, 100);
		RtlZeroMemory(&temp, sizeof(temp));
		RtlZeroMemory(&object_context, sizeof(object_context));		
		
		GetDroitFile(DesiredAccess, droit);
		
		RtlUnicodeStringToAnsiString(&ansi_cible,  ObjectAttributes->ObjectName, TRUE);
		if(ansi_cible.Buffer == NULL)
			return retour;
		type =  GetObjectType(ObjectAttributes->ObjectName);
		RtlZeroMemory(&securitycontext,525);
		GetSecurityContextSubject(process, securitycontext);
	
		
		switch(type)
		{
			case 1:
				if(_stricmp(&ansi_cible.Buffer[strlen(ansi_cible.Buffer)-strlen(".exe")], ".exe") == 0 )
				{
					TransformToContextFile(ansi_cible,temp);
					sprintf(object_context,"system_u:object_r:%s_exec_t", temp);
					bool = 1;
					//WriteInLog(droit, process.pid, process.pathname, process.ppid, ansi_cible.Buffer, securitycontext, object_context, "file");
				}
				
				if(_stricmp(&ansi_cible.Buffer[strlen(ansi_cible.Buffer)-strlen(".dll")], ".dll") == 0 )
				{
					TransformToContextFile(ansi_cible,temp);
					sprintf(object_context,"system_u:object_r:%s_lib_t", temp);
					bool =1;
					//WriteInLog(droit, process.pid, process.pathname, process.ppid, ansi_cible.Buffer, securitycontext, object_context, "file");
				}
				
				if(_stricmp(&ansi_cible.Buffer[strlen(ansi_cible.Buffer)-strlen(".tmp")], ".tmp") == 0 )
				{
					TransformToContextFile(ansi_cible,temp);
					sprintf(object_context,"system_u:object_r:%s_tmp_t", temp);
					bool = 1;
					//WriteInLog(droit, process.pid, process.pathname, process.ppid, ansi_cible.Buffer, securitycontext, object_context, "file");
				}
				if(object_context == NULL)
				{
					TransformToContextFile(ansi_cible,temp);					
					sprintf(object_context,"system_u:object_r:%s_file_t", temp);
					bool = 1;
					//WriteInLog(droit, process.pid, process.pathname, process.ppid, ansi_cible.Buffer, securitycontext, object_context, "file");
				}
		   		 break;
			case 2:
				if(_stricmp(&ansi_cible.Buffer[strlen(ansi_cible.Buffer)-strlen(".sys")], ".sys") == 0 )
				{
					TransformToContextFile(ansi_cible,temp);	
					sprintf(object_context,"system_u:object_r:%s_driver_t", temp);
					WriteInLog(droit, process.pid, process.pathname, process.ppid, ansi_cible.Buffer, securitycontext, object_context, "driver", retour,0);
				}
				break;
			case 3:
				i=7;
				j=0;
				taille = strlen(ansi_cible.Buffer);
				RtlZeroMemory(&temp, sizeof(temp));
				while(i< taille)
				{
					if(ansi_cible.Buffer[i] == '\\')
					{
						temp[j] = '|';
					}
					else
					{
						if(ansi_cible.Buffer[i] == ' ')
						{
							j=j-1;
						}
						else
						{
							temp[j] = ansi_cible.Buffer[i];
						}
					}
					i++;
					j++;
				}
				if(temp[j-1] == '|')
					temp[j-1]='\0';
				
				if(strlen(ansi_cible.Buffer) == 7)
					strncpy(temp,"system_t",strlen("system_t"));
				else
					strcat(temp,"_dir_t");

				sprintf(object_context,"system_u:object_r:%s", temp);
				WriteInLog(droit, process.pid, process.pathname, process.ppid, ansi_cible.Buffer, securitycontext, object_context, "dir", retour,0);
				break;
			case 4:
				WriteInLog(droit, process.pid, process.pathname, process.ppid, ansi_cible.Buffer, securitycontext, "system_u:object_r:device_t", "device", retour,0);
				break;
			default:
				break;	
		}
		
		if(bool == 1)
			WriteInLog(droit, process.pid, process.pathname, process.ppid, ansi_cible.Buffer, securitycontext, object_context, "file", retour,0);
		
		RtlFreeAnsiString(&ansi_cible);

	} 
	return retour;
}



NTSTATUS NewNtCreateFile(
                    PHANDLE FileHandle,
                    ACCESS_MASK DesiredAccess,
                    POBJECT_ATTRIBUTES ObjectAttributes,
                    PIO_STATUS_BLOCK IoStatusBlock,
                    PLARGE_INTEGER AllocationSize OPTIONAL,
                    ULONG FileAttributes,
                    ULONG ShareAccess,
                    ULONG CreateDisposition,
                    ULONG CreateOptions,
                    PVOID EaBuffer OPTIONAL,
                    ULONG EaLength
					)
{
	NTSTATUS retour,status;
	ULONG retLen, ret;
    UNICODE_STRING        *path_str = NULL;
	ANSI_STRING ansi_cible;
	ProcessInformationFile process;
	ProcessInformation process_uni ;
	int type=0,taille,i,j, retour_autorite=0;
	char droit[300];
	char temp[1024];
	char object_context[1024];
	char securitycontext[525];
	ANSI_STRING pathname_ansi;
	int bool=0;
	
	// PAGED_CODE();
	
	__try{
	retour = ((NTCREATEFILE)(OldNtCreateFile)) (
							FileHandle,
							DesiredAccess,
							ObjectAttributes,
							IoStatusBlock,
							AllocationSize,
							FileAttributes,
							ShareAccess,
							CreateDisposition,
							CreateOptions,
							EaBuffer,							EaLength);
							
	}
	__except(1)
	{
	}
							
	
	if(ExGetPreviousMode() == KernelMode)
		return retour;
		
	process = GetProcessInfoFile();
	
	if(process.pid == (int)UserLandID)
		return retour;
	
	if(ExGetPreviousMode() == UserMode)
	{
		RtlZeroMemory(&droit, 100);
						
		GetDroitFile(DesiredAccess, droit);
					
		type =  GetObjectType(ObjectAttributes->ObjectName);
		RtlUnicodeStringToAnsiString(&ansi_cible,  ObjectAttributes->ObjectName, TRUE);
		RtlZeroMemory(&securitycontext,525);
		GetSecurityContextSubject(process, securitycontext);
	
		RtlZeroMemory(&temp, sizeof(temp));
		RtlZeroMemory(&object_context, sizeof(object_context));	
		
		switch(type)
		{
			case 1:
				if(_stricmp(&ansi_cible.Buffer[strlen(ansi_cible.Buffer)-strlen(".exe")], ".exe") == 0 )
				{
					TransformToContextFile(ansi_cible,temp);
					sprintf(object_context,"system_u:object_r:%s_exec_t", temp);
					bool = 1;
				}
				
				if(_stricmp(&ansi_cible.Buffer[strlen(ansi_cible.Buffer)-strlen(".dll")], ".dll") == 0 )
				{
					TransformToContextFile(ansi_cible,temp);
					sprintf(object_context,"system_u:object_r:%s_lib_t", temp);
					bool =1;
				}
				
				if(_stricmp(&ansi_cible.Buffer[strlen(ansi_cible.Buffer)-strlen(".tmp")], ".tmp") == 0 )
				{
					TransformToContextFile(ansi_cible,temp);
					sprintf(object_context,"system_u:object_r:%s_tmp_t", temp);
					bool = 1;
				}
				if(object_context == NULL)
				{
					//TransformToContextFile(ansi_cible,temp);					
					// sprintf(object_context,"system_u:object_r:%s_file_t");
					WriteInLog(droit, process.pid, process.pathname, process.ppid, ansi_cible.Buffer, securitycontext, "system_u:object_r:file_t", "file", retour,0);
				}
		   		 break;
			case 2:
				if(_stricmp(&ansi_cible.Buffer[strlen(ansi_cible.Buffer)-strlen(".sys")], ".sys") == 0 )
				{
					TransformToContextFile(ansi_cible,temp);	
					sprintf(object_context,"system_u:object_r:%s_driver_t", temp);
					WriteInLog(droit, process.pid, process.pathname, process.ppid, ansi_cible.Buffer, securitycontext, object_context, "driver", retour,0);
				}
				break;
			case 3:
				i=7;
				j=0;
				taille = strlen(ansi_cible.Buffer);
				RtlZeroMemory(&temp, sizeof(temp));
				while(i< taille)
				{
					if(ansi_cible.Buffer[i] == '\\')
					{
						temp[j] = '|';
					}
					else
					{
						if(ansi_cible.Buffer[i] == ' ')
						{
							j=j-1;
						}
						else
						{
							temp[j] = ansi_cible.Buffer[i];
						}
					}
					i++;
					j++;
				}
				if(temp[j-1] == '|')
					temp[j-1]='\0';
				
				if(strlen(ansi_cible.Buffer) == 7)
					strncpy(temp,"system_t",strlen("system_t"));
				else
					strcat(temp,"_dir_t");

				sprintf(object_context,"system_u:object_r:%s", temp);
				WriteInLog(droit, process.pid, process.pathname, process.ppid, ansi_cible.Buffer, securitycontext, object_context, "dir", retour,0);
				break;
			case 4:
				WriteInLog(droit, process.pid, process.pathname, process.ppid, ansi_cible.Buffer, securitycontext, "system_u:object_r:device_t", "device", retour,0);
				break;
			default:
				break;	
		}
		
		if(bool == 1)
			WriteInLog(droit, process.pid, process.pathname, process.ppid, ansi_cible.Buffer, securitycontext, object_context, "file", retour,0);
		
		RtlFreeAnsiString(&ansi_cible);

	} 
		return retour;
}


NTSTATUS NewNtReadFile (
    __in HANDLE FileHandle,
    __in_opt HANDLE Event,
    __in_opt PIO_APC_ROUTINE ApcRoutine,
    __in_opt PVOID ApcContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __out_bcount(Length) PVOID Buffer,
    __in ULONG Length,
    __in_opt PLARGE_INTEGER ByteOffset,
    __in_opt PULONG Key
    )
{
	NTSTATUS retour,ntStatus;
	ProcessInformationFile process;
	PFILE_OBJECT fileObject = NULL;
	ANSI_STRING ansi_cible;
	IO_STATUS_BLOCK iostatus;
	ULONG retLen, ret;
    UNICODE_STRING        *path_str = NULL;
	PPUBLIC_OBJECT_TYPE_INFORMATION publicobj;
	int type=0, taille=0, i=0,j=0, bool=0;
	char temp[1024];
	char object_context[1024];
	char securitycontext[525];
	char droit[20];
	int done = 0;
	
	PAGED_CODE();
	
	retour = ((NTREADFILE)(OldNtReadFile))(
						FileHandle,
						Event,
						ApcRoutine,
						ApcContext,
						IoStatusBlock,
						Buffer,
						Length,
						ByteOffset,
						Key);

						
	process = GetProcessInfoFile();
	
	if(process.pid == (int)UserLandID)
		return retour;				
	
	if(ExGetPreviousMode() == UserMode)
	{
	
			if(FileHandle != NULL)
			{
				ObReferenceObjectByHandle(FileHandle, 0, 0, KernelMode, &fileObject, NULL);
		
				if (fileObject)
				{
					ntStatus = ObQueryNameString(fileObject, (POBJECT_NAME_INFORMATION)path_str, 0, &retLen);
					path_str = (PUNICODE_STRING)ExAllocatePoolWithTag(NonPagedPool, retLen, 0);
					if (ntStatus == STATUS_INFO_LENGTH_MISMATCH)
					{
						if (path_str)
						{
							ntStatus = ObQueryNameString(fileObject, (POBJECT_NAME_INFORMATION)path_str, retLen, &retLen);
						}
						else 
						{
							// if(fileObject)
								// ObDereferenceObject(fileObject);
							return retour;	
						}
					}
				
					RtlUnicodeStringToAnsiString(&ansi_cible,  path_str, TRUE);
					type =  GetObjectType(path_str);
					
					RtlZeroMemory(&temp, sizeof(temp));
					RtlZeroMemory(&object_context, sizeof(object_context));	
					RtlZeroMemory(&securitycontext,525);
					GetSecurityContextSubject(process, securitycontext);
					
					sprintf(droit,"read ");
					switch(type)
						{
							case 1:
								// DbgPrint("read : %s\n", Buffer);
								if(_stricmp(&ansi_cible.Buffer[strlen(ansi_cible.Buffer)-strlen(".exe")], ".exe") == 0 )
								{
									TransformToContextFile(ansi_cible,temp);
									sprintf(object_context,"system_u:object_r:%s_exec_t", temp);
									bool = 1;
								}
								
								if(_stricmp(&ansi_cible.Buffer[strlen(ansi_cible.Buffer)-strlen(".dll")], ".dll") == 0 )
								{
									TransformToContextFile(ansi_cible,temp);
									sprintf(object_context,"system_u:object_r:%s_lib_t", temp);
									bool =1;
								}
								
								if(_stricmp(&ansi_cible.Buffer[strlen(ansi_cible.Buffer)-strlen(".tmp")], ".tmp") == 0 )
								{
									TransformToContextFile(ansi_cible,temp);
									sprintf(object_context,"system_u:object_r:%s_tmp_t", temp);
									bool = 1;
								}
								if(object_context == NULL)
								{
									TransformToContextFile(ansi_cible,temp);					
									sprintf(object_context,"system_u:object_r:%s_file_t", temp);
									bool = 1;
								}
								if(bool ==0)
								{
									// TransformToContextFile(ansi_cible,temp);					
									sprintf(object_context,"system_u:object_r:file_t");
									bool = 1;
								}
								 break;
							case 2:
								if(_stricmp(&ansi_cible.Buffer[strlen(ansi_cible.Buffer)-strlen(".sys")], ".sys") == 0 )
								{
									TransformToContextFile(ansi_cible,temp);	
									sprintf(object_context,"system_u:object_r:%s_driver_t", temp);
									WriteInLog(droit, process.pid, process.pathname, process.ppid, ansi_cible.Buffer, securitycontext, object_context, "driver", retour,Length);
								}
								break;
							case 3:
								i=7;
								j=0;
								taille = strlen(ansi_cible.Buffer);
								RtlZeroMemory(&temp, sizeof(temp));
								while(i< taille)
								{
									if(ansi_cible.Buffer[i] == '\\')
									{
										temp[j] = '|';
									}
									else
									{
										if(ansi_cible.Buffer[i] == ' ')
										{
											j=j-1;
										}
										else
										{
											temp[j] = ansi_cible.Buffer[i];
										}
									}
									i++;
									j++;
								}
								if(temp[j-1] == '|')
									temp[j-1]='\0';
								
								if(strlen(ansi_cible.Buffer) == 7)
									strncpy(temp,"system_t",strlen("system_t"));
								else
									strcat(temp,"_dir_t");

								sprintf(object_context,"system_u:object_r:%s", temp);
								WriteInLog(droit, process.pid, process.pathname, process.ppid, ansi_cible.Buffer, securitycontext, object_context, "dir", retour,Length);
								break;
							case 4:
								WriteInLog(droit, process.pid, process.pathname, process.ppid, ansi_cible.Buffer, securitycontext, "system_u:object_r:device_t", "device", retour,Length);
								break;
							default:
								break;	
						}
						
						if(bool == 1)
							WriteInLog(droit, process.pid, process.pathname, process.ppid, ansi_cible.Buffer, securitycontext, object_context, "file", retour,Length);
					// SendRequest(process.pid,process.pathname, ansi_cible.Buffer,process.pid, "file", "read");
				
				}
				
				if(fileObject)
					ObDereferenceObject(fileObject);
			}
			
	}
	
	return retour;
}

NTSTATUS NewNtWriteFile (
    __in HANDLE FileHandle,
    __in_opt HANDLE Event,
    __in_opt PIO_APC_ROUTINE ApcRoutine,
    __in_opt PVOID ApcContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __out_bcount(Length) PVOID Buffer,
    __in ULONG Length,
    __in_opt PLARGE_INTEGER ByteOffset,
    __in_opt PULONG Key
    )
{
	NTSTATUS retour,ntStatus;
	ProcessInformationFile process;
	ProcessInformation process_uni;
	PFILE_OBJECT fileObject = NULL;
	ANSI_STRING ansi_cible, pathname_ansi;
	IO_STATUS_BLOCK iostatus;
	ULONG retLen, ret;
    UNICODE_STRING        *path_str = NULL;
	// PPUBLIC_OBJECT_TYPE_INFORMATION publicobj;
	int type=0, taille=0, i=0,j=0,bool=1;
	// char temp[1024];
	char object_context[1024];
	char securitycontext[525];
	char droit[20];
	
	PAGED_CODE();
	
	retour = ((NTWRITEFILE)(OldNtWriteFile))(
						FileHandle,
						Event,
						ApcRoutine,
						ApcContext,
						IoStatusBlock,
						Buffer,
						Length,
						ByteOffset,
						Key);
						

	process_uni = GetProcessInfo();
	
	if(process_uni.pid == (int)UserLandID)
		return retour;			

	if(ExGetPreviousMode() == UserMode)
	{
									
			if(FileHandle != NULL)
			{
				ObReferenceObjectByHandle(FileHandle, 0, 0, KernelMode, &fileObject, NULL);
		
				if (fileObject)
				{
					ntStatus = ObQueryNameString(fileObject, (POBJECT_NAME_INFORMATION)path_str, 0, &retLen);
					path_str = (PUNICODE_STRING)ExAllocatePoolWithTag(NonPagedPool, retLen, 0);
					if (ntStatus == STATUS_INFO_LENGTH_MISMATCH)
					{
						if (path_str)
						{
							ntStatus = ObQueryNameString(fileObject, (POBJECT_NAME_INFORMATION)path_str, retLen, &retLen);
						}
						else 
						{
							if(fileObject)
								ObDereferenceObject(fileObject);
							return retour;	
						}
					}
				
					ntStatus = RtlUnicodeStringToAnsiString(&ansi_cible,  path_str, TRUE);
					type =  GetObjectType(path_str);
					
					RtlZeroMemory(&object_context, sizeof(object_context));	
					RtlZeroMemory(&securitycontext,525);
					GetSecurityContextSubjectReg(process_uni.name,securitycontext);
					// // GetSecurityContextSubject(process, securitycontext);
					sprintf(droit,"write ");
					switch(type)
						{
							case 1:
								// TransformToContextFile(ansi_cible,temp);					
									// sprintf(object_context,"system_u:object_r:file_t");
											 // DbgPrint("write : %s \n", Buffer);
									WriteInLog(droit,process_uni.pid, process_uni.name, process_uni.ppid, ansi_cible.Buffer, securitycontext, "system_u:object_r:file_t", "file", retour,Length);
									// bool = 1;
								 // break;
							case 4:
									WriteInLog(droit,process_uni.pid,process_uni.name, process_uni.ppid, ansi_cible.Buffer, securitycontext, "system_u:object_r:device_t", "device", retour,Length);
								break;
							default:
								break;	
						}
						
					// // if(bool == 1)
							// // WriteInLog(droit,process_uni.pid, &pathname_ansi.Buffer[4], process_uni.ppid, ansi_cible.Buffer, securitycontext, object_context, "file", retour);
					if(fileObject)
						ObDereferenceObject(fileObject);
				}
					
			}
	}
	
	return retour;
}

void GetDroitFile( ACCESS_MASK DesiredAccess, char * droit)
{
		if( (DesiredAccess & FILE_READ_DATA) || (DesiredAccess &STANDARD_RIGHTS_READ) )
		{
			sprintf(droit,"read ");
		}	
		if( (DesiredAccess & FILE_EXECUTE) || (DesiredAccess & FILE_GENERIC_EXECUTE ) )
		{
			sprintf(droit,"%sexecute ", droit);
		}
		if( (DesiredAccess & FILE_WRITE_DATA) || (DesiredAccess & STANDARD_RIGHTS_WRITE) )
		{
			sprintf(droit,"%swrite ", droit);
		}
		if( (DesiredAccess & STANDARD_RIGHTS_WRITE ) ||  (DesiredAccess & FILE_WRITE_DATA) ||  (DesiredAccess & FILE_WRITE_ATTRIBUTES ) \
		||  (DesiredAccess & FILE_WRITE_EA ) ||  (DesiredAccess & FILE_APPEND_DATA ) )
		{
			sprintf(droit,"%screate ", droit);
		}
		if ( (DesiredAccess & DELETE) )
		{	
			sprintf(droit,"%sunlink ", droit);
		}
		if( (DesiredAccess & FILE_READ_ATTRIBUTES) || (DesiredAccess & READ_CONTROL) )
		{
			sprintf(droit,"%sgetattr ", droit);
		}
		if( (DesiredAccess & FILE_WRITE_ATTRIBUTES) || (DesiredAccess & WRITE_DAC)  || (DesiredAccess & FILE_WRITE_EA) )
		{
			sprintf(droit,"%ssetattr ", droit);
		}
		if ( (DesiredAccess & FILE_APPEND_DATA) )
		{
			sprintf(droit,"%sappend ", droit);
		}
		if ( (DesiredAccess & MAXIMUM_ALLOWED) )
		{
			sprintf(droit,"%smax ", droit);	
		}
		if ( (DesiredAccess & ACCESS_SYSTEM_SECURITY) )
		{
			sprintf(droit,"%ssec ", droit);
		}
		
		if ( (DesiredAccess & GENERIC_READ) )
		{
			sprintf(droit,"%sgen_read ", droit);
		}
		
		if ( (DesiredAccess & GENERIC_WRITE) )
		{
			sprintf(droit,"%sgen_write ", droit);
		}
		
		if ( (DesiredAccess & GENERIC_EXECUTE) )
		{
			sprintf(droit,"%sgen_exec ", droit);
		}
		
		if ( (DesiredAccess & GENERIC_ALL) )
		{
			sprintf(droit,"%sgen_all ", droit);
		}
}
