#include "main.h"

WSADATA wsaData;
SOCKET ConnectSocket;
HANDLE th_handle;
HANDLE th_handle_net;
HANDLE pipehandle;
HANDLE pipehandle_net;
HANDLE driverhandle;
int exit_th;

void Install()
{
    schSCManager = OpenSCManager(0,0,SC_MANAGER_ALL_ACCESS);
    installation();
}

void Suppression()
{
    schSCManager = OpenSCManager(0,0,SC_MANAGER_ALL_ACCESS);
    suppression();
}

void SetDebugPrivilege()
{
	    TOKEN_PRIVILEGES privilege;
 	    LUID Luid;
	    HANDLE handle1;
	    HANDLE handle2;
 	    handle1 = OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetCurrentProcessId());
 	    OpenProcessToken(handle1, TOKEN_ALL_ACCESS, &handle2);
 	    LookupPrivilegeValue(NULL, SE_DEBUG_NAME , &Luid);
 	    privilege.PrivilegeCount = 1;
 	    privilege.Privileges[0].Luid = Luid;
 	    privilege.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
 	    AdjustTokenPrivileges(handle2, FALSE, &privilege, sizeof(privilege), NULL, NULL);
	    CloseHandle(handle2);
	    CloseHandle(handle1);
}

void ListenDriverNet()
{
    char buffernet[2000];
    DWORD dw1;

    while(TRUE)
    {
        ZeroMemory(buffernet, sizeof(buffernet));
        ReadFile(pipehandle_net, &buffernet, sizeof(buffernet), &dw1, NULL);
        if(exit_th == 1)
        {
            CloseHandle(pipehandle_net);
            break;
        }
       // printf("%s\n", buffernet);
        MakeXMLNet(buffernet);
    }
}

void ListenDriver()
{
     char buffer[2024];
    DWORD dw1;

    while(TRUE)
    {
        ZeroMemory(buffer, sizeof(buffer));
        ReadFile(pipehandle, &buffer, sizeof(buffer), &dw1, NULL);
        if(exit_th == 1)
        {
            CloseHandle(pipehandle);
            break;
        }
  // printf("%s\n", buffer);
    MakeXML(buffer);
    }
}

void SetLoadDriverPrivilege()
{
    TOKEN_PRIVILEGES privilege;
    LUID Luid;
    HANDLE handle1;
    HANDLE handle2;
    handle1 = OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetCurrentProcessId());
    OpenProcessToken(handle1, TOKEN_ALL_ACCESS, &handle2);
    LookupPrivilegeValue(NULL, SE_LOAD_DRIVER_NAME , &Luid);
    privilege.PrivilegeCount = 1;
    privilege.Privileges[0].Luid = Luid;
    privilege.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    AdjustTokenPrivileges(handle2, FALSE, &privilege, sizeof(privilege), NULL, NULL);
    CloseHandle(handle2);
    CloseHandle(handle1);
}

int main(int argc, char *argv[])
{
    DWORD dw;
    exit_th =0;

    if(argc > 1)
    {
        if(strcmp(argv[1],"-i")==0 )
            Install();
        else
            if(strcmp(argv[1],"-d")==0)
                Suppression();
            else
            {
                printf("Mauvaise option\n");
                printf("-i : installe le driver qui sera charge au demarrage\n");
                printf("-d : desinstalle le driver \n");
            }
        return 1;
    }

    //debut du programme
    printf("Appuyez sur une touche pour initialiser la connexion\n");
    system("pause 1 >Nul");
    Initialize();

    if(connection())
    {
        printf("connexion echouee, appuyez sur une touche pour sortir du programme\n");
        system("pause 1>null");
        return 1;
    }
    SetDebugPrivilege();
    printf("Connexion etablie");
    pipehandle = CreateNamedPipe("\\\\.\\\\pipe\\framework", PIPE_ACCESS_DUPLEX, PIPE_TYPE_MESSAGE,2, 2024, 2024, 0, 0);
    if(pipehandle ==  INVALID_HANDLE_VALUE)
    {
        printf("Error pipehandle\n");
        closeconnection();
        system("pause");
        return 1;
    }

     pipehandle_net = CreateNamedPipe("\\\\.\\\\pipe\\frameworkNet", PIPE_ACCESS_DUPLEX, PIPE_TYPE_MESSAGE,2, 2024, 2024, 0, 0);
    if(pipehandle ==  INVALID_HANDLE_VALUE)
    {
        printf("Error pipehandle\n");
        closeconnection();
        system("pause");
        return 1;
    }

    //Envoie IOCTL pour que le driver place les hooks ainsi que les callback
    driverhandle = CreateFile("\\\\.\\dkf",GENERIC_READ|GENERIC_WRITE,0,0,OPEN_EXISTING,FILE_ATTRIBUTE_SYSTEM,0);
    if(driverhandle == INVALID_HANDLE_VALUE)
    {
        suppression();
        printf("Error CreateFile failed \n");
        system("pause");
        return 2;
    }
    else
    {
        DeviceIoControl(driverhandle,IOCTL_DKF_START,NULL,0,NULL,0,&dw,0);
    }

    printf("Hook et callback ok\n");

    // lancement du Threaad
    th_handle =  CreateThread(0,0,(LPTHREAD_START_ROUTINE) ListenDriver,0,0,&dw);
    th_handle_net =  CreateThread(0,0,(LPTHREAD_START_ROUTINE) ListenDriverNet,0,0,&dw);
    printf("Pressez une touche pour arrêter le programme\n");
    system("pause 1>Nul");

    exit_th = 1;
    TerminateThread(th_handle_net,0);
    TerminateThread(th_handle,0);

    if(pipehandle)
        CloseHandle(pipehandle);

    printf("de-hook \n");
    DeviceIoControl(driverhandle,IOCTL_DKF_STOP,NULL,0,NULL,0,&dw,0);
    printf("Fermeture de la connexion \n");
    system("pause 1>Nul");

    closeconnection();
    return 0;
}


void MakeXML(char * buffer)
{
    int i=0,j=0;
    char type[20];// = (char *)malloc(sizeof(char));
    char droit[200];// = (char *)malloc(sizeof(char));
    char timespamp[30];// = (char *)malloc(sizeof(char));
    char id[20] ;// = (char *)malloc(sizeof(char));
    char pid[8] ;// = (char *)malloc(sizeof(char));
    char ppid[8];// = (char *)malloc(sizeof(char));
    char scontext[500] ;//= (char *)malloc(sizeof(char));
    char name[1024] ;//= (char *)malloc(sizeof(char));
    char tcontext[1024] ;// = (char *)malloc(sizeof(char));
    char objname[1024] ;//= (char *)malloc(sizeof(char));
    char retour[10] ;//= (char *)ma
    char size[100];


    char   buffer_final[5096];

    if(strstr(buffer,"endoftrace") == NULL)
        return;
    ZeroMemory(buffer_final, sizeof(buffer_final));
    ZeroMemory(droit, sizeof(droit));
    ZeroMemory(type, sizeof(type));
    ZeroMemory(timespamp, sizeof(timespamp));
    ZeroMemory(id  , sizeof(id));
    ZeroMemory(ppid, sizeof(ppid));
    ZeroMemory(pid, sizeof(pid));
    ZeroMemory(name, sizeof(name));
    ZeroMemory(objname, sizeof(objname));
    ZeroMemory(scontext, sizeof(scontext));
    ZeroMemory(tcontext, sizeof(tcontext));
    ZeroMemory(retour, sizeof(retour));
    ZeroMemory(size, sizeof(size));

    while(i < (int)strlen(buffer))
    {
        while(buffer[i] != '(') i++;
        i++;
        j=0;
        while(buffer[i] != ',') // get timestamp
        {
            timespamp[j] = buffer[i];
            i++;
            j++;
        }
        timespamp[j]='\0';
        i++;
        j=0;
        while(buffer[i] != ')')// get id
        {
            id[j]=buffer[i];
            i++;
            j++;
        }
        id[j]='\0';
        while(buffer[i] != '{') i++;
        j=0;
        i++;
        while(buffer[i] != '}') // get rights
        {
            droit[j]=buffer[i];
            i++;
            j++;
        }
        droit[j]='\0';
        while(buffer[i] != '=') i++;
        j=0;
        i++;
        while(buffer[i] != ' ') // get pid
        {
            pid[j]=buffer[i];
            i++;
            j++;
        }
        pid[j]='\0';
        while(buffer[i] != '"') i++;
        i++;
        j=0;
        while(buffer[i] != '"') // get name
        {
            name[j]=buffer[i];
            i++;
            j++;
        }
        name[j]='\0';
        while(buffer[i] != '=') i++;
        j=0;
        i++;
        while(buffer[i] != ' ') // get pid
        {
            ppid[j]=buffer[i];
            i++;
            j++;
        }
        ppid[j]='\0';
        while(buffer[i] != '"') i++;
        i++;
        j=0;
        while(buffer[i] != '"') // get objname
        {
            objname[j]=buffer[i];
            i++;
            j++;
        }
        objname[j]='\0';
        while(buffer[i] != '=') i++;
        j=0;
        i++;
        while(buffer[i] != ' ') // get scontext
        {
            scontext[j]=buffer[i];
            i++;
            j++;
        }
        scontext[j]='\0';
        while(buffer[i] != '=') i++;
        j=0;
        i++;
        while(buffer[i] != ' ') // get tcontext
        {
            tcontext[j]=buffer[i];
            i++;
            j++;
        }
        tcontext[j]='\0';
        while(buffer[i] != '=') i++;
        j=0;
        i++;
        while(buffer[i] != ' ') // get type
        {
            type[j]=buffer[i];
            i++;
            j++;
        }
        type[j]='\0';
        while(buffer[i] != '=') i++;
        j=0;
        i++;
        while(buffer[i] != ' ') // get retour
        {
            retour[j]=buffer[i];
            i++;
            j++;
        }
        retour[j]='\0';
        while(buffer[i] != '=') i++;
        j=0;
        i++;
        //break;
        while(buffer[i] != ' ') // get retour
        {
            size[j]=buffer[i];
            i++;
            j++;
        }
        size[j]='\0';
        break;
    }

    sprintf(buffer_final, "<trace id=\"%s\" timestamp=\"%s\" >\n\t<class type=\"%s\" return=\"%s\" />\n\t<process pid=\"%s\" ppid=\"%s\" scontext=\"%s\" name=\"%s\" />\n\t<object name=\"%s\" tcontext=\"%s\" rights=\"%s\" size=\"%s\" />\n\t<data>\n\t</data>\n</trace>\n", id, timespamp, type, retour, pid, ppid, scontext,name,objname, tcontext, droit, size);
printf("%s\n", buffer_final);
  sendmesg(buffer_final);
}


void MakeXMLNet(char * buffer)
{
    int i=0,j=0;
    char type[20];// = (char *)malloc(sizeof(char));
    char typecon[10];// = (char *)malloc(sizeof(char));
    char prot[10];// = (char *)malloc(sizeof(char));
    char timespamp[30];// = (char *)malloc(sizeof(char));
    char id[20] ;// = (char *)malloc(sizeof(char));
    char pid[8] ;// = (char *)malloc(sizeof(char));
    char ppid[8];// = (char *)malloc(sizeof(char));
    char scontext[500] ;//= (char *)malloc(sizeof(char));
    char name[1024] ;//= (char *)malloc(sizeof(char));
    char retour[15] ;//= (char *)ma
    char size[100];
    char temp[20];
    char   buffer_final[5096];
    TCPInfo tcp;
    UDPInfo udp;

    if(strstr(buffer,"endoftrace") == NULL)
        return;
    ZeroMemory(buffer_final, sizeof(buffer_final));
    ZeroMemory(typecon, sizeof(typecon));
    ZeroMemory(type, sizeof(type));
    ZeroMemory(prot, sizeof(prot));
    ZeroMemory(timespamp, sizeof(timespamp));
    ZeroMemory(id  , sizeof(id));
    ZeroMemory(ppid, sizeof(ppid));
    ZeroMemory(pid, sizeof(pid));
    ZeroMemory(name, sizeof(name));
    ZeroMemory(temp, sizeof(temp));
    ZeroMemory(scontext, sizeof(scontext));
    ZeroMemory(retour, sizeof(retour));
    ZeroMemory(size, sizeof(size));

//audit(129412850090651712,1) pid=3384 name=iexplore.exe ppid=3308 { send } size=16 prot=tcp return=0 endoftrace
    while(i < (int)strlen(buffer))
    {
        while(buffer[i] != '(') i++;
        i++;
        j=0;
        while(buffer[i] != ',') // get timestamp
        {
            timespamp[j] = buffer[i];
            i++;
            j++;
        }
        timespamp[j]='\0';
        i++;
        j=0;
        while(buffer[i] != ')')// get id
        {
            id[j]=buffer[i];
            i++;
            j++;
        }
        id[j]='\0';
        while(buffer[i] != '=') i++;
        j=0;
        i++;
         while(buffer[i] != ' ') // get pid
        {
            pid[j]=buffer[i];
            i++;
            j++;
        }
        pid[j]='\0';
        while(buffer[i] != '=') i++;
        j=0;
        i++;
         while(buffer[i] != ' ') // get name
        {
            name[j]=buffer[i];
            i++;
            j++;
        }
        name[j]='\0';
        while(buffer[i] != '=') i++;
        j=0;
        i++;
        while(buffer[i] != ' ') // get pid
        {
            ppid[j]=buffer[i];
            i++;
            j++;
        }
        ppid[j]='\0';
        while(buffer[i] != '{') i++;
        j=0;
        i++;
        i++;
        while(buffer[i] != ' ') // get rights
        {
            typecon[j]=buffer[i];
            i++;
            j++;
        }
        typecon[j]='\0';
        while(buffer[i] != '=') i++;
        j=0;
        i++;
        while(buffer[i] != ' ') // get rights
        {
            size[j]=buffer[i];
            i++;
            j++;
        }
        size[j]='\0';
        while(buffer[i] != '=') i++;
        j=0;
        i++;
        while(buffer[i] != ' ') // get rights
        {
            prot[j]=buffer[i];
            i++;
            j++;
        }
        prot[j]='\0';
        while(buffer[i] != '=') i++;
        j=0;
        i++;
        while(buffer[i] != ' ') // get rights
        {
            retour[j]=buffer[i];
            i++;
            j++;
        }
        retour[j]='\0';
        break;
    }
    i=0;
    while(i < 16 )
    {
        if(name[i] == '.')
            break;
        temp[i] = name[i];
        i++;
    }
    sprintf(scontext, "system_u:system_r:%s_t", temp);

    if(strcmp(prot , "tcp") == 0)
    {

        tcp = GetIpTcp(atoi(pid));
        sprintf(buffer_final, "<trace id=\"%s\" timestamp=\"%s\" >\n\t<class type=\"network\" return=\"%s\" />\n\t<process pid=\"%s\" ppid=\"%s\" scontext=\"%s\" name=\"%s\" />\n\t<ip ipsource=\"%s\" portsource=\"%i\" ipdest=\"%s\" portdest=\"%i\" state=\"%s\" typeconnect=\"%s\" size=\"%s\" prot=\"%s\" />\n\t<data>\n\t</data>\n</trace>\n", \
                id, timespamp, retour, pid, ppid, scontext, name, tcp.localip, tcp.localport, tcp.distip, tcp.distport, tcp.state, typecon,size, prot);//
    }

    if(strcmp(prot, "udp") == 0)
    {
        udp = GetUdpInfo(atoi(pid));
        sprintf(buffer_final, "<trace id=\"%s\" timestamp=\"%s\" >\n\t<class type=\"network\" return=\"%s\" />\n\t<process pid=\"%s\" ppid=\"%s\" scontext=\"%s\" name=\"%s\" />\n\t<ip ipsource=\"%s\" portsource=\"%i\" ipdest=\"0\" portdest=\"0\" state=\"NONE\" typeconnect=\"%s\" size=\"%s\" prot=\"%s\" />\n\t<data>\n\t</data>\n</trace>\n", \
                id, timespamp, retour, pid, ppid, scontext, name, udp.localip, udp.localport,  typecon,size, prot);//
    }
 printf("%s\n", buffer_final);
//    printf("%s\n", buffer_final);
  sendmesg(buffer_final);
}


TCPInfo GetIpTcp(int pidsearch)
{
    PMIB_TCPTABLE_OWNER_PID  pTcpTable;
    DWORD dwSize = 0;
    DWORD dwRetVal = 0;
    struct in_addr IpAddr;
    int i=0;
    TCPInfo tcp;

    pTcpTable = ( MIB_TCPTABLE_OWNER_PID  *) MALLOC(sizeof ( PMIB_TCPTABLE_OWNER_PID ));
    if (pTcpTable == NULL) {
        printf("Error allocating memory\n");
        return tcp;
    }
    dwSize = sizeof ( PMIB_TCPTABLE_OWNER_PID );
    if ((dwRetVal = GetExtendedTcpTable(pTcpTable, &dwSize, TRUE, AF_INET, TCP_TABLE_OWNER_PID_ALL,0)) ==
        ERROR_INSUFFICIENT_BUFFER) {
        FREE(pTcpTable);
        pTcpTable = ( MIB_TCPTABLE_OWNER_PID  *) MALLOC(dwSize);
        if (pTcpTable == NULL) {
            printf("Error allocating memory\n");
            return tcp;
        }
    }

    if ((dwRetVal =GetExtendedTcpTable(pTcpTable, &dwSize, TRUE, AF_INET, TCP_TABLE_OWNER_PID_ALL,0)) == NO_ERROR)
    {
        while(pTcpTable->table[i].dwOwningPid != pidsearch && i<(int) pTcpTable->dwNumEntries)
            i++;

       switch (pTcpTable->table[i].dwState)
       {
            case MIB_TCP_STATE_CLOSED:
                sprintf(tcp.state ,"CLOSED");
                break;
            case MIB_TCP_STATE_LISTEN:
                sprintf(tcp.state ,"LISTEN");
                break;
            case MIB_TCP_STATE_SYN_SENT:
                sprintf(tcp.state ,"SYN-SENT");
                break;
            case MIB_TCP_STATE_SYN_RCVD:
                sprintf(tcp.state ,"SYN-RECEIVED");
                break;
            case MIB_TCP_STATE_ESTAB:
                sprintf(tcp.state ,"ESTABLISHED");
                break;
            case MIB_TCP_STATE_FIN_WAIT1:
                sprintf(tcp.state ,"FIN-WAIT-1");
                break;
            case MIB_TCP_STATE_FIN_WAIT2:
                sprintf(tcp.state ,"FIN-WAIT-2");
                break;
            case MIB_TCP_STATE_CLOSE_WAIT:
                sprintf(tcp.state ,"CLOSE-WAIT");
                break;
            case MIB_TCP_STATE_CLOSING:
                sprintf(tcp.state ,"CLOSING");
                break;
            case MIB_TCP_STATE_LAST_ACK:
                sprintf(tcp.state ,"LAST-ACK");
                break;
            case MIB_TCP_STATE_TIME_WAIT:
               sprintf(tcp.state ,"TIME-WAIT");
                break;
            case MIB_TCP_STATE_DELETE_TCB:
                sprintf(tcp.state ,"DELETE-TCB");
                break;
            default:
                sprintf(tcp.state ,"UNKNOWN");
                break;
        }

            IpAddr.S_un.S_addr = (u_long) pTcpTable->table[i].dwLocalAddr;
            strcpy(tcp.localip, inet_ntoa(IpAddr));
            tcp.localport = ntohs((u_short)pTcpTable->table[i].dwLocalPort) ;

            IpAddr.S_un.S_addr = (u_long) pTcpTable->table[i].dwRemoteAddr;
            strcpy(tcp.distip, inet_ntoa(IpAddr));
            tcp.distport = ntohs((u_short)pTcpTable->table[i].dwRemotePort);
    }
    return tcp;
}

int connection()
{
     //----------------------
    // Declare and initialize variables.
    int iResult;
    struct sockaddr_in clientService;

    //----------------------
    // Initialize Winsock
    iResult = WSAStartup(MAKEWORD(2,2), &wsaData);
    if (iResult != NO_ERROR) {
        printf("WSAStartup failed with error: %d\n", iResult);
        return 1;
    }

    //----------------------
    // Create a SOCKET for connecting to server
    ConnectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (ConnectSocket == INVALID_SOCKET) {
        printf("socket failed with error: %i\n", WSAGetLastError());
        WSACleanup();
        return 1;
    }

   // setsockopt(ConnectSocket,  IPPROTO_TCP, TCP_NODELAY,(char *) &flag,sizeof(int));
    //----------------------
    // The sockaddr_in structure specifies the address family,
    // IP address, and port of the server to be connected to.
    clientService.sin_family = AF_INET;
    clientService.sin_addr.s_addr = inet_addr( "172.30.3.57" );
    clientService.sin_port = htons( DEFAULT_PORT );

    //----------------------
    // Connect to server.
    iResult = connect( ConnectSocket, (SOCKADDR*) &clientService, sizeof(clientService) );
    if (iResult == SOCKET_ERROR) {
        printf( "connect failed with error: %d\n", WSAGetLastError() );
        closesocket(ConnectSocket);
        WSACleanup();
        return 1;
    }
    return 0;
}


int sendmesg(char * sendbuf)
{
    int iResult;
    DWORD dw;
    //----------------------
    // Send an initial buffer
    if(sendbuf == NULL)
    {
        printf("Buff send NUll \n");
        return 0;
    }

    else
        iResult = send( ConnectSocket, sendbuf, (int)strlen(sendbuf), 0 );

    if (iResult == SOCKET_ERROR) {
        printf("send() failed with error: %d\n", WSAGetLastError());
        printf("%s\n", sendbuf);
        closesocket(ConnectSocket);
         TerminateThread(th_handle,0);

        if(pipehandle)
            CloseHandle(pipehandle);

        printf("de-hook \n");
        DeviceIoControl(driverhandle,IOCTL_DKF_STOP,NULL,0,NULL,0,&dw,0);
        WSACleanup();
        return 1;
    }
    return 0;
}

int closeconnection()
{
    closesocket(ConnectSocket);
    WSACleanup();
    return 1;
}
