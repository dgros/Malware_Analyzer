#include "main.h"


typedef enum  {
  UDP_TABLE_BASIC,
  UDP_TABLE_OWNER_PID,
  UDP_TABLE_OWNER_MODULE
} UDP_TABLE_CLASS, *PUDP_TABLE_CLASS;



typedef struct _MIB_UDPROW_OWNER_PID {
  DWORD dwLocalAddr;
  DWORD dwLocalPort;
  DWORD dwOwningPid;
} MIB_UDPROW_OWNER_PID, *PMIB_UDPROW_OWNER_PID;
typedef struct _MIB_UDPTABLE_OWNER_PID {
  DWORD                dwNumEntries;
  MIB_UDPROW_OWNER_PID table[ANY_SIZE];
} MIB_UDPTABLE_OWNER_PID, *PMIB_UDPTABLE_OWNER_PID;

DWORD (WINAPI * GetExtendedUdpTable) (
        PVOID pUdpTable,
        PDWORD pdwSize,
        BOOL bOrder,
        ULONG ulAf,
        UDP_TABLE_CLASS TableClass,
        ULONG Reserved
);


void Initialize()
{

    HMODULE hmod;
    hmod = LoadLibrary("Iphlpapi.dll");

     if(hmod)
    {
        GetExtendedUdpTable  = ( DWORD (WINAPI *) ( PVOID , PDWORD,   BOOL,    ULONG,   UDP_TABLE_CLASS ,  ULONG ) ) GetProcAddress(hmod, "GetExtendedUdpTable");
    }


}

UDPInfo GetUdpInfo(int pidsearch)
{

    PMIB_UDPTABLE_OWNER_PID pUdpTable;
    DWORD dwSize = 0;
    DWORD dwRetVal = 0;

    struct in_addr IpAddr;
    int i=0;
    UDPInfo udp;

    pUdpTable = (MIB_UDPTABLE_OWNER_PID *) MALLOC(sizeof (MIB_UDPTABLE_OWNER_PID));
    if (pUdpTable == NULL) {
        printf("Error allocating memory\n");
        return udp;
    }

    dwSize = sizeof (PMIB_UDPTABLE_OWNER_PID);
// Make an initial call to GetTcpTable to
// get the necessary size into the dwSize variable
    if ((dwRetVal = GetExtendedUdpTable(pUdpTable, &dwSize, TRUE,AF_INET, UDP_TABLE_OWNER_PID, 0)) ==
        ERROR_INSUFFICIENT_BUFFER) {
        FREE(pUdpTable);
        pUdpTable = (MIB_UDPTABLE_OWNER_PID *) MALLOC(dwSize);
        if (pUdpTable == NULL) {
            printf("Error allocating memory\n");
            return udp;
        }
    }
// Make a second call to GetTcpTable to get
// the actual data we require

    dwRetVal = GetExtendedUdpTable(pUdpTable, &dwSize, TRUE,AF_INET, UDP_TABLE_OWNER_PID, 0);

    if (dwRetVal == NO_ERROR)
    {
         while(pUdpTable->table[i].dwOwningPid != pidsearch && i<(int) pUdpTable->dwNumEntries)
            i++;

            IpAddr.S_un.S_addr = (u_long) pUdpTable->table[i].dwLocalAddr;
            strcpy(udp.localip, inet_ntoa(IpAddr) );
            udp.localport =ntohs((u_short)pUdpTable->table[i].dwLocalPort) ;

    } else {
        printf("\tGetTcpTable failed with %i\n", (int)dwRetVal);
        FREE(pUdpTable);
        return udp;
    }

    if (pUdpTable != NULL) {
        FREE(pUdpTable);
        pUdpTable = NULL;
    }

    return udp;
}
